From 8b11a5cc26e1867856c7d5ab715cd3f8a284a29b Mon Sep 17 00:00:00 2001
From: Mingcong Bai <jeffbai@aosc.xyz>
Date: Wed, 21 Feb 2024 16:58:32 -0500
Subject: [PATCH 83/89] [LOONGARCH64] arch/loongarch: add la_ow_syscall as
 in-tree module

Co-authored-By: Miao Wang <shankerwangmiao@gmail.com>
---
 arch/loongarch/Kbuild                         |   2 +
 arch/loongarch/ow_syscall/Kbuild              |  26 ++
 arch/loongarch/ow_syscall/LICENSE             | 339 ++++++++++++++++++
 arch/loongarch/ow_syscall/Makefile            |  37 ++
 arch/loongarch/ow_syscall/README.md           |  74 ++++
 arch/loongarch/ow_syscall/VERSION             |   1 +
 arch/loongarch/ow_syscall/dkms.conf.in        |   7 +
 arch/loongarch/ow_syscall/fsstat.c            |  84 +++++
 arch/loongarch/ow_syscall/fsstat.h            |   3 +
 .../loongarch/ow_syscall/la_ow_syscall_main.c | 326 +++++++++++++++++
 arch/loongarch/ow_syscall/signal.c            | 222 ++++++++++++
 arch/loongarch/ow_syscall/signal.h            |  41 +++
 12 files changed, 1162 insertions(+)
 create mode 100644 arch/loongarch/ow_syscall/Kbuild
 create mode 100644 arch/loongarch/ow_syscall/LICENSE
 create mode 100644 arch/loongarch/ow_syscall/Makefile
 create mode 100644 arch/loongarch/ow_syscall/README.md
 create mode 100644 arch/loongarch/ow_syscall/VERSION
 create mode 100644 arch/loongarch/ow_syscall/dkms.conf.in
 create mode 100644 arch/loongarch/ow_syscall/fsstat.c
 create mode 100644 arch/loongarch/ow_syscall/fsstat.h
 create mode 100644 arch/loongarch/ow_syscall/la_ow_syscall_main.c
 create mode 100644 arch/loongarch/ow_syscall/signal.c
 create mode 100644 arch/loongarch/ow_syscall/signal.h

diff --git a/arch/loongarch/Kbuild b/arch/loongarch/Kbuild
index bfa21465d83a..52ddcb17537c 100644
--- a/arch/loongarch/Kbuild
+++ b/arch/loongarch/Kbuild
@@ -8,3 +8,5 @@ obj-$(CONFIG_BUILTIN_DTB) += boot/dts/
 
 # for cleaning
 subdir- += boot
+
+obj-y += ow_syscall/
diff --git a/arch/loongarch/ow_syscall/Kbuild b/arch/loongarch/ow_syscall/Kbuild
new file mode 100644
index 000000000000..f3921c3fd96d
--- /dev/null
+++ b/arch/loongarch/ow_syscall/Kbuild
@@ -0,0 +1,26 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for LoongArch old-world syscall compatible layer.
+#
+
+ifdef KBUILD_EXTMOD
+CONFIG_LOONGARCH_OW_SYSCALL := m
+endif
+
+obj-$(CONFIG_LOONGARCH_OW_SYSCALL) += la_ow_syscall.o
+la_ow_syscall-y += fsstat.o la_ow_syscall_main.o signal.o
+
+ifndef KBUILD_EXTMOD
+  ifdef CONFIG_KALLSYMS
+$(obj)/ksym_addr.h: System.map
+	@$(kecho) '  GEN     $@'
+	$(Q)grep ' sys_call_table$$' $< >/dev/null
+	$(Q)grep ' kallsyms_lookup_name$$' $< >/dev/null
+	$(Q)grep ' system_state$$' $< >/dev/null
+	$(Q)echo "#define LAOWSYS_SYS_CALL_TABLE_ADDR 0x$$(grep ' sys_call_table$$' $< | cut -d ' ' -f 1)ul" > $@
+	$(Q)echo "#define LAOWSYS_KALLSYMS_LOOKUP_NAME_ADDR 0x$$(grep ' kallsyms_lookup_name$$' $< | cut -d ' ' -f 1)ul" >> $@
+	$(Q)echo "#define LAOWSYS_SYSTEM_STATE_ADDR 0x$$(grep ' system_state$$' $< | cut -d ' ' -f 1)ul" >> $@
+ccflags-y += -DHAVE_KSYM_ADDR
+$(obj)/$(la_ow_syscall-y): $(obj)/ksym_addr.h
+  endif
+endif
diff --git a/arch/loongarch/ow_syscall/LICENSE b/arch/loongarch/ow_syscall/LICENSE
new file mode 100644
index 000000000000..d159169d1050
--- /dev/null
+++ b/arch/loongarch/ow_syscall/LICENSE
@@ -0,0 +1,339 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/arch/loongarch/ow_syscall/Makefile b/arch/loongarch/ow_syscall/Makefile
new file mode 100644
index 000000000000..e975aa1cdb7a
--- /dev/null
+++ b/arch/loongarch/ow_syscall/Makefile
@@ -0,0 +1,37 @@
+obj-m += la_ow_syscall.o fsstat.o la_ow_syscall_main.o signal.o
+
+KVER ?= $(shell uname -r)
+KDIR ?= /lib/modules/$(KVER)/build
+VERSION ?= $(shell cat VERSION)
+
+default:
+	$(MAKE) -C $(KDIR) M=$(CURDIR) modules
+
+clean:
+	$(MAKE) -C $(KDIR) M=$(CURDIR) clean
+
+install:
+	$(MAKE) -C $(KDIR) M=$(CURDIR) modules_install
+
+dkms.conf: dkms.conf.in
+	m4 -DVERSION=$(VERSION) $^ > $@
+
+dkms-add: dkms.conf
+	/usr/sbin/dkms add $(CURDIR)
+
+dkms-build: dkms.conf
+	/usr/sbin/dkms build la_ow_syscall/$(VERSION)
+
+dkms-install: dkms.conf
+	/usr/sbin/dkms install la_ow_syscall/$(VERSION)
+
+dkms-remove: dkms.conf
+	/usr/sbin/dkms remove la_ow_syscall/$(VERSION) --all
+
+modprobe-install:
+	modprobe la_ow_syscall
+
+modprobe-remove:
+	modprobe -r la_ow_syscall
+
+dev: modprobe-remove dkms-remove dkms-add dkms-build dkms-install modprobe-install
diff --git a/arch/loongarch/ow_syscall/README.md b/arch/loongarch/ow_syscall/README.md
new file mode 100644
index 000000000000..24ec0eae161f
--- /dev/null
+++ b/arch/loongarch/ow_syscall/README.md
@@ -0,0 +1,74 @@
+la\_ow\_syscall
+====
+
+This kernel modules provides compatibility with LoongArch's old-world ABI,
+making it possible to run old-world applications (such as Kingsoft's WPS Office
+and Tencent QQ) transparently on new-world (ABI 2.0) kernels and userspaces.
+
+Requirements
+----
+
+Linux Kernel >= 6.1.0 for `loongarch64` with the following option(s) set:
+
+- `CONFIG_KALLSYMS=y` (for reading kernel symbol addresses).
+
+Installation
+----
+
+You may install this kernel both as an in-tree module, an out-of-tree DKMS
+dynamic module, or a version-specific module. You may pick any option that best
+suits your needs.
+
+### In-tree module
+
+Copy this source tree as `arch/loongarch/ow_syscall` in your kernel tree and
+append the following to `arch/loongarch/Kbuild`:
+
+```
+obj-y += ow_syscall/
+```
+
+After building the kernel with `make`, run the following command to build the
+kernel module:
+
+```
+# $PWD is the kernel source root.
+make \
+    -C ${PWD} \
+    ARCH=loongarch \
+    O=(pwd) \
+    arch/loongarch/ow_syscall/la_ow_syscall.ko \
+    CONFIG_LOONGARCH_OW_SYSCALL=m
+```
+
+Upon completion, copy the kernel module in place
+(`/usr/lib/modules/.../arch/loongarch/ow_syscall/la_ow_syscall.ko`) and
+re-generate modules.dep and map files:
+
+```
+depmod
+```
+
+### DKMS dynamic module
+
+Generate a `dkms.conf`:
+
+```
+make dkms.conf
+```
+
+For installation and version management, refer to dkms(8) for details.
+
+### Version-specific module
+
+Build the kernel module:
+
+```
+make
+```
+
+Load the module with super user or root privilege:
+
+```
+insmod la_ow_syscall.ko
+```
diff --git a/arch/loongarch/ow_syscall/VERSION b/arch/loongarch/ow_syscall/VERSION
new file mode 100644
index 000000000000..6c6aa7cb0918
--- /dev/null
+++ b/arch/loongarch/ow_syscall/VERSION
@@ -0,0 +1 @@
+0.1.0
\ No newline at end of file
diff --git a/arch/loongarch/ow_syscall/dkms.conf.in b/arch/loongarch/ow_syscall/dkms.conf.in
new file mode 100644
index 000000000000..b2a3493106c2
--- /dev/null
+++ b/arch/loongarch/ow_syscall/dkms.conf.in
@@ -0,0 +1,7 @@
+PACKAGE_NAME="la_ow_syscall"
+PACKAGE_VERSION="VERSION"
+MAKE="KDIR=/lib/modules/${kernelver}/build make"
+CLEAN="make clean"
+BUILT_MODULE_NAME[0]="la_ow_syscall"
+AUTOINSTALL="yes"
+DEST_MODULE_LOCATION[0]="/extra"
diff --git a/arch/loongarch/ow_syscall/fsstat.c b/arch/loongarch/ow_syscall/fsstat.c
new file mode 100644
index 000000000000..e540d6ff2548
--- /dev/null
+++ b/arch/loongarch/ow_syscall/fsstat.c
@@ -0,0 +1,84 @@
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+#include <linux/errno.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include "fsstat.h"
+
+#define INIT_STRUCT_STAT_PADDING(st) memset(&st, 0, sizeof(st))
+
+struct __old_kernel_stat {
+	unsigned short st_dev;
+	unsigned short st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned int st_size;
+	unsigned int st_atime;
+	unsigned int st_mtime;
+	unsigned int st_ctime;
+};
+
+static int cp_new_stat(struct kstat *stat, struct stat __user *statbuf)
+{
+	struct stat tmp;
+
+	if (sizeof(tmp.st_dev) < 4 && !old_valid_dev(stat->dev))
+		return -EOVERFLOW;
+	if (sizeof(tmp.st_rdev) < 4 && !old_valid_dev(stat->rdev))
+		return -EOVERFLOW;
+#if BITS_PER_LONG == 32
+	if (stat->size > MAX_NON_LFS)
+		return -EOVERFLOW;
+#endif
+
+	INIT_STRUCT_STAT_PADDING(tmp);
+	tmp.st_dev = new_encode_dev(stat->dev);
+	tmp.st_ino = stat->ino;
+	if (sizeof(tmp.st_ino) < sizeof(stat->ino) && tmp.st_ino != stat->ino)
+		return -EOVERFLOW;
+	tmp.st_mode = stat->mode;
+	tmp.st_nlink = stat->nlink;
+	if (tmp.st_nlink != stat->nlink)
+		return -EOVERFLOW;
+	SET_UID(tmp.st_uid, from_kuid_munged(current_user_ns(), stat->uid));
+	SET_GID(tmp.st_gid, from_kgid_munged(current_user_ns(), stat->gid));
+	tmp.st_rdev = new_encode_dev(stat->rdev);
+	tmp.st_size = stat->size;
+	tmp.st_atime = stat->atime.tv_sec;
+	tmp.st_mtime = stat->mtime.tv_sec;
+	tmp.st_ctime = stat->ctime.tv_sec;
+#ifdef STAT_HAVE_NSEC
+	tmp.st_atime_nsec = stat->atime.tv_nsec;
+	tmp.st_mtime_nsec = stat->mtime.tv_nsec;
+	tmp.st_ctime_nsec = stat->ctime.tv_nsec;
+#endif
+	tmp.st_blocks = stat->blocks;
+	tmp.st_blksize = stat->blksize;
+	return copy_to_user(statbuf, &tmp, sizeof(tmp)) ? -EFAULT : 0;
+}
+
+__SYSCALL_DEFINEx(2, _newfstat, unsigned int, fd, struct stat __user *, statbuf)
+{
+	struct kstat stat;
+	int error = p_vfs_fstat(fd, &stat);
+
+	if (!error)
+		error = cp_new_stat(&stat, statbuf);
+
+	return error;
+}
+
+__SYSCALL_DEFINEx(4, _newfstatat, int, dfd, const char __user *, filename,
+		  struct stat __user *, statbuf, int, flag)
+{
+	struct kstat stat;
+	int error;
+
+	error = p_vfs_fstatat(dfd, filename, &stat, flag);
+	if (error)
+		return error;
+	return cp_new_stat(&stat, statbuf);
+}
diff --git a/arch/loongarch/ow_syscall/fsstat.h b/arch/loongarch/ow_syscall/fsstat.h
new file mode 100644
index 000000000000..7c970ad8fd00
--- /dev/null
+++ b/arch/loongarch/ow_syscall/fsstat.h
@@ -0,0 +1,3 @@
+extern int (*p_vfs_fstatat)(int dfd, const char __user *filename,
+			    struct kstat *stat, int flags);
+extern int (*p_vfs_fstat)(int fd, struct kstat *stat);
diff --git a/arch/loongarch/ow_syscall/la_ow_syscall_main.c b/arch/loongarch/ow_syscall/la_ow_syscall_main.c
new file mode 100644
index 000000000000..3308ef082539
--- /dev/null
+++ b/arch/loongarch/ow_syscall/la_ow_syscall_main.c
@@ -0,0 +1,326 @@
+#include <linux/module.h> /* Needed by all modules */
+#include <linux/kernel.h> /* Needed for KERN_INFO */
+#include <linux/init.h> /* Needed for the macros */
+#include <linux/kprobes.h> /* Needed for kprobe calls */
+
+///< The license type -- this affects runtime behavior
+MODULE_LICENSE("GPL");
+
+///< The author -- visible when you use modinfo
+MODULE_AUTHOR("Miao Wang");
+
+///< The description -- see modinfo
+MODULE_DESCRIPTION("LoongArch old-world syscall compatibility module");
+
+///< The version of the module
+MODULE_VERSION("0.1.0");
+
+#include <linux/kallsyms.h>
+#include <linux/syscalls.h>
+
+#define __EXTERN
+#include "fsstat.h"
+#include "signal.h"
+
+#define __ARCH_WANT_SET_GET_RLIMIT
+#define __ARCH_WANT_NEW_STAT
+#undef __SYSCALL
+#define __SYSCALL(nr, call) [nr] = (#call),
+
+const char *sys_call_table_name[__NR_syscalls] = {
+	[0 ... __NR_syscalls - 1] = "sys_ni_syscall",
+#include <asm/unistd.h>
+};
+
+#ifndef __loongarch64
+#error This Linux kernel module is only supported on LoongArch
+#endif
+
+#ifdef HAVE_KSYM_ADDR
+#include "ksym_addr.h"
+#endif
+
+static struct {
+	long syscall_num;
+	void *symbol_addr;
+	void *orig;
+} syscall_to_replace[] = {
+	{ __NR_fstat, sys_newfstat },
+	{ __NR_newfstatat, sys_newfstatat },
+	{ __NR_getrlimit, NULL },
+	{ __NR_setrlimit, NULL },
+	{ __NR_rt_sigprocmask, sys_rt_sigprocmask },
+	{ __NR_rt_sigpending, sys_rt_sigpending },
+	{ __NR_rt_sigtimedwait, sys_rt_sigtimedwait },
+	{ __NR_rt_sigaction, sys_rt_sigaction },
+	{ __NR_rt_sigsuspend, sys_rt_sigsuspend },
+	{ __NR_pselect6, sys_pselect6 },
+#ifdef CONFIG_SIGNALFD
+	{ __NR_signalfd4, sys_signalfd4 },
+#endif
+#ifdef CONFIG_EPOLL
+	{ __NR_epoll_pwait, sys_epoll_pwait },
+	{ __NR_epoll_pwait2, sys_epoll_pwait2 },
+#endif
+};
+
+#define nr_syscalls_to_replace \
+	(sizeof(syscall_to_replace) / sizeof(syscall_to_replace[0]))
+
+static unsigned long kallsyms_lookup_name_addr = 0;
+static unsigned int allow_mod_unreg = 0;
+
+#include <asm-generic/sections.h>
+
+#ifdef HAVE_KSYM_ADDR
+static int __init find_kallsyms_lookup_name(void)
+{
+	unsigned long offset =
+		(unsigned long)&system_state - LAOWSYS_SYSTEM_STATE_ADDR;
+	pr_debug("kernel offset = %lx\n", offset);
+	kallsyms_lookup_name_addr = offset + LAOWSYS_KALLSYMS_LOOKUP_NAME_ADDR;
+	pr_debug("using kallsyms_lookup_name @ %p\n",
+		 (void *)kallsyms_lookup_name_addr);
+	return 0;
+}
+#else
+// Taken from https://github.com/zizzu0/LinuxKernelModules/blob/main/FindKallsymsLookupName.c
+#define KPROBE_PRE_HANDLER(fname) \
+	static int __kprobes fname(struct kprobe *p, struct pt_regs *regs)
+
+static struct kprobe kp0, kp1;
+
+KPROBE_PRE_HANDLER(handler_pre0)
+{
+	kallsyms_lookup_name_addr = regs->csr_era;
+
+	return 0;
+}
+
+KPROBE_PRE_HANDLER(handler_pre1)
+{
+	return 0;
+}
+
+#undef KPROBE_PRE_HANDLER
+
+static int do_register_kprobe(struct kprobe *kp, char *symbol_name,
+			      void *handler)
+{
+	int ret = 0;
+
+	kp->symbol_name = symbol_name;
+	kp->pre_handler = handler;
+
+	ret = register_kprobe(kp);
+	if (ret < 0) {
+		pr_err("register_probe() for symbol %s failed, returned %d\n",
+		       symbol_name, ret);
+		return ret;
+	}
+
+	pr_debug("planted kprobe for symbol %s at %p\n", symbol_name, kp->addr);
+
+	return ret;
+}
+
+static int __init find_kallsyms_lookup_name(void)
+{
+	char fn_name[KSYM_SYMBOL_LEN];
+
+	int ret = 0;
+
+	ret = do_register_kprobe(&kp0, "kallsyms_lookup_name", handler_pre0);
+	if (ret < 0)
+		return ret;
+
+	ret = do_register_kprobe(&kp1, "kallsyms_lookup_name", handler_pre1);
+	if (ret < 0) {
+		unregister_kprobe(&kp0);
+		return ret;
+	}
+
+	unregister_kprobe(&kp0);
+	unregister_kprobe(&kp1);
+
+	if (kallsyms_lookup_name_addr == 0 ||
+	    kallsyms_lookup_name_addr == (unsigned long)-1) {
+		return -EINVAL;
+	}
+	sprint_symbol(fn_name, kallsyms_lookup_name_addr);
+	if (strncmp(fn_name, "kallsyms_lookup_name+0x0",
+		    strlen("kallsyms_lookup_name+0x0")) == 0) {
+		pr_debug("got kallsyms_lookup_name = %lx\n",
+			 kallsyms_lookup_name_addr);
+		return 0;
+	} else {
+		pr_debug("got %s at %lx, not kallsyms_lookup_name\n", fn_name,
+			 kallsyms_lookup_name_addr);
+		return -EINVAL;
+	}
+}
+#endif
+
+
+int (*p_vfs_fstatat)(int dfd, const char __user *filename, struct kstat *stat,
+		     int flags);
+int (*p_vfs_fstat)(int fd, struct kstat *stat);
+
+void *p_sys_setxattr, *p_sys_close, *p_sys_clone;
+
+static struct {
+	const char *func_name;
+	void **stor;
+} relocation_table[] = {
+#define __rel(func)                             \
+	{                                       \
+		(#func), ((void **)&(p_##func)) \
+	}
+	__rel(vfs_fstatat),	  __rel(vfs_fstat),
+	__rel(sys_setxattr),	  __rel(sys_close),
+	__rel(sys_clone),	  __rel(sys_rt_sigprocmask),
+	__rel(sys_rt_sigpending), __rel(sys_rt_sigtimedwait),
+	__rel(sys_rt_sigaction),  __rel(sys_rt_sigsuspend),
+	__rel(sys_pselect6),
+#ifdef CONFIG_SIGNALFD
+	__rel(sys_signalfd4),
+#endif
+#ifdef CONFIG_EPOLL
+	__rel(sys_epoll_pwait),	  __rel(sys_epoll_pwait2),
+#endif
+};
+#define nr_rel_tab (sizeof(relocation_table) / sizeof(relocation_table[0]))
+
+static void **p_sys_call_table;
+
+#ifdef HAVE_KSYM_ADDR
+static int __init find_sys_call_table(void)
+{
+	unsigned long offset =
+		(unsigned long)&system_state - LAOWSYS_SYSTEM_STATE_ADDR;
+	pr_debug("kernel offset = %lx\n", offset);
+	p_sys_call_table = (void **)(offset + LAOWSYS_SYS_CALL_TABLE_ADDR);
+	pr_debug("using sys_call_table @ %p\n", p_sys_call_table);
+	return 0;
+}
+#else
+
+#include <linux/jiffies.h>
+#include <linux/reboot.h>
+static int __init find_sys_call_table(void)
+{
+	unsigned long (*p_kallsyms_lookup_name)(const char *name) =
+		(void *)kallsyms_lookup_name_addr;
+	unsigned long *sys_table;
+
+	if (kallsyms_lookup_name_addr == 0) {
+		return -ENOSYS;
+	}
+
+	if ((sys_table = (unsigned long *)p_kallsyms_lookup_name(
+		     "sys_call_table"))) {
+		p_sys_call_table = (void **)sys_table;
+		pr_debug("found sys_call_table=%px\n", p_sys_call_table);
+		return 0;
+	}
+
+	pr_info("failed to find sys_call_table using kallsyms_lookup_name()\n");
+	pr_info("trying to find sys_call_table using memory scanning\n");
+
+	for (sys_table = (void *)&jiffies;
+	     (void *)sys_table < (void *)&reboot_mode; sys_table++) {
+		if (sys_table[__NR_setxattr] == (unsigned long)p_sys_setxattr &&
+		    sys_table[__NR_close] == (unsigned long)p_sys_close &&
+		    sys_table[__NR_clone] == (unsigned long)p_sys_clone) {
+			p_sys_call_table = (void **)sys_table;
+			pr_debug("found sys_call_table=%px\n",
+				 p_sys_call_table);
+			return 0;
+		}
+	}
+
+	return -ENOSYS;
+}
+#endif
+
+static int __init oldsyscall_start(void)
+{
+	unsigned long (*p_kallsyms_lookup_name)(const char *name);
+	int rc = find_kallsyms_lookup_name();
+	if (rc < 0) {
+		return rc;
+	}
+	p_kallsyms_lookup_name = (void *)kallsyms_lookup_name_addr;
+
+	for (int i = 0; i < nr_rel_tab; i++) {
+		unsigned long p =
+			p_kallsyms_lookup_name(relocation_table[i].func_name);
+		if (p == 0) {
+			pr_warn("cannot find symbol %s\n",
+				relocation_table[i].func_name);
+			return -EINVAL;
+		}
+		pr_debug("found symbol %s at %px\n",
+			 relocation_table[i].func_name, (void *)p);
+		*relocation_table[i].stor = (void *)p;
+	}
+	rc = find_sys_call_table();
+	if (rc < 0) {
+		return rc;
+	}
+	for (int i = 0; i < nr_syscalls_to_replace; i++) {
+		if (syscall_to_replace[i].symbol_addr) {
+			continue;
+		}
+		const char *symbol_name =
+			sys_call_table_name[syscall_to_replace[i].syscall_num];
+		unsigned long symbol_addr = p_kallsyms_lookup_name(symbol_name);
+		if (symbol_addr) {
+			pr_debug("found %s at %px\n", symbol_name,
+				 (void *)symbol_addr);
+		} else {
+			pr_warn("cannot find symbol %s\n", symbol_name);
+			return -EINVAL;
+		}
+		syscall_to_replace[i].symbol_addr = (void *)symbol_addr;
+	}
+	if (!allow_mod_unreg) {
+		bool succ = try_module_get(THIS_MODULE);
+		if (!succ) {
+			return -EINVAL;
+		}
+	}
+	for (int i = 0; i < nr_syscalls_to_replace; i++) {
+		pr_debug("will replace syscall_%ld with %px, orig %px\n",
+			 syscall_to_replace[i].syscall_num,
+			 syscall_to_replace[i].symbol_addr,
+			 p_sys_call_table[syscall_to_replace[i].syscall_num]);
+		syscall_to_replace[i].orig =
+			p_sys_call_table[syscall_to_replace[i].syscall_num];
+		p_sys_call_table[syscall_to_replace[i].syscall_num] =
+			syscall_to_replace[i].symbol_addr;
+	}
+	pr_info("la_ow_syscall module successfully initialized\n");
+	return 0;
+}
+
+static void __exit oldsyscall_end(void)
+{
+	for (int i = 0; i < nr_syscalls_to_replace; i++) {
+		pr_debug("will restore syscall_%ld to %px\n",
+			 syscall_to_replace[i].syscall_num,
+			 syscall_to_replace[i].orig);
+		p_sys_call_table[syscall_to_replace[i].syscall_num] =
+			syscall_to_replace[i].orig;
+	}
+}
+
+module_init(oldsyscall_start);
+module_exit(oldsyscall_end);
+module_param(allow_mod_unreg, uint, 0000);
+MODULE_PARM_DESC(allow_mod_unreg,
+		 "Allow this module to be unload (Danger! Debug use only)");
+#ifndef HAVE_KSYM_ADDR
+module_param(kallsyms_lookup_name_addr, ulong, 0000);
+MODULE_PARM_DESC(kallsyms_lookup_name_addr, "Address for kallsyms_lookup_name");
+#endif
diff --git a/arch/loongarch/ow_syscall/signal.c b/arch/loongarch/ow_syscall/signal.c
new file mode 100644
index 000000000000..1593fdba30c2
--- /dev/null
+++ b/arch/loongarch/ow_syscall/signal.c
@@ -0,0 +1,222 @@
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include "signal.h"
+
+#define _LA_OW_NSIG 128
+#define _LA_OW_NSIG_WORDS (_LA_OW_NSIG / _NSIG_BPW)
+
+typedef struct {
+	unsigned long sig[_LA_OW_NSIG_WORDS];
+} _la_ow_sigset_t;
+
+static inline int clear_user_sigset_extension(sigset_t __user *to)
+{
+	char __user *expansion = (char __user *)to + sizeof(sigset_t);
+	int rc = clear_user(expansion,
+			    sizeof(_la_ow_sigset_t) - sizeof(sigset_t));
+	if (rc < 0) {
+		return -EFAULT;
+	}
+	return 0;
+}
+
+__SYSCALL_DEFINEx(4, _rt_sigprocmask, int, how, sigset_t __user *, nset,
+		  sigset_t __user *, oset, size_t, sigsetsize)
+{
+	if (sigsetsize == sizeof(sigset_t)) {
+		return p_sys_rt_sigprocmask(how, nset, oset, sigsetsize);
+	} else if (sigsetsize == sizeof(_la_ow_sigset_t)) {
+		int rc =
+			p_sys_rt_sigprocmask(how, nset, oset, sizeof(sigset_t));
+		if (rc < 0) {
+			return rc;
+		}
+		if (oset) {
+			int rc2 = clear_user_sigset_extension(oset);
+			if (rc2 < 0) {
+				return rc2;
+			}
+		}
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+}
+
+__SYSCALL_DEFINEx(2, _rt_sigpending, sigset_t __user *, uset, size_t,
+		  sigsetsize)
+{
+	if (sigsetsize == sizeof(sigset_t)) {
+		return p_sys_rt_sigpending(uset, sigsetsize);
+	} else if (sigsetsize == sizeof(_la_ow_sigset_t)) {
+		int rc = p_sys_rt_sigpending(uset, sizeof(sigset_t));
+		if (rc < 0) {
+			return rc;
+		}
+		int rc2 = clear_user_sigset_extension(uset);
+		if (rc2 < 0) {
+			return rc2;
+		}
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+}
+
+__SYSCALL_DEFINEx(4, _rt_sigtimedwait, const sigset_t __user *, uthese,
+		  siginfo_t __user *, uinfo,
+		  const struct __kernel_timespec __user *, uts, size_t,
+		  sigsetsize)
+{
+	if (sigsetsize == sizeof(sigset_t)) {
+		return p_sys_rt_sigtimedwait(uthese, uinfo, uts, sigsetsize);
+	} else if (sigsetsize == sizeof(_la_ow_sigset_t)) {
+		int rc = p_sys_rt_sigtimedwait(uthese, uinfo, uts,
+					       sizeof(sigset_t));
+		if (rc < 0) {
+			return rc;
+		}
+		return rc;
+	} else {
+		return -EINVAL;
+	}
+}
+
+__SYSCALL_DEFINEx(4, _rt_sigaction, int, sig, const struct sigaction __user *,
+		  act, struct sigaction __user *, oact, size_t, sigsetsize)
+{
+	if (sigsetsize == sizeof(sigset_t)) {
+		return p_sys_rt_sigaction(sig, act, oact, sigsetsize);
+	} else if (sigsetsize == sizeof(_la_ow_sigset_t)) {
+		int rc = p_sys_rt_sigaction(sig, act, oact, sizeof(sigset_t));
+		if (rc < 0) {
+			return rc;
+		}
+		if (oact) {
+			int rc2 = clear_user_sigset_extension(&oact->sa_mask);
+			if (rc2 < 0) {
+				return rc2;
+			}
+		}
+		return rc;
+	} else {
+		return -EINVAL;
+	}
+}
+
+__SYSCALL_DEFINEx(2, _rt_sigsuspend, sigset_t __user *, unewset, size_t,
+		  sigsetsize)
+{
+	if (sigsetsize == sizeof(sigset_t)) {
+		return p_sys_rt_sigsuspend(unewset, sigsetsize);
+	} else if (sigsetsize == sizeof(_la_ow_sigset_t)) {
+		int rc = p_sys_rt_sigsuspend(unewset, sizeof(sigset_t));
+		if (rc < 0) {
+			return rc;
+		}
+		return rc;
+	} else {
+		return -EINVAL;
+	}
+}
+
+__SYSCALL_DEFINEx(6, _pselect6, int, n, fd_set __user *, inp, fd_set __user *,
+		  outp, fd_set __user *, exp, struct __kernel_timespec __user *,
+		  tsp, void __user *, sig)
+{
+	struct sigset_argpack {
+		sigset_t __user *p;
+		size_t size;
+	} x = { NULL, 0 };
+	struct sigset_argpack __user *siginfo =
+		(struct sigset_argpack __user *)sig;
+
+	if (siginfo) {
+		int rc = get_user(x.size, &siginfo->size);
+		if (rc < 0) {
+			return -EFAULT;
+		}
+	}
+	if (siginfo == NULL || x.size == sizeof(sigset_t)) {
+		return p_sys_pselect6(n, inp, outp, exp, tsp, sig);
+	} else if (x.size == sizeof(_la_ow_sigset_t)) {
+		int rc = put_user(sizeof(sigset_t), &siginfo->size);
+		if (rc < 0) {
+			return -EFAULT;
+		}
+		rc = p_sys_pselect6(n, inp, outp, exp, tsp, sig);
+		int rc2 = put_user(sizeof(_la_ow_sigset_t), &siginfo->size);
+		if (rc2 < 0) {
+			return -EFAULT;
+		}
+		return rc;
+	} else {
+		return -EINVAL;
+	}
+}
+
+#ifdef CONFIG_EPOLL
+
+__SYSCALL_DEFINEx(6, _epoll_pwait, int, epfd, struct epoll_event __user *,
+		  events, int, maxevents, int, timeout, const sigset_t __user *,
+		  sigmask, size_t, sigsetsize)
+{
+	if (sigmask == NULL || sigsetsize == sizeof(sigset_t)) {
+		return p_sys_epoll_pwait(epfd, events, maxevents, timeout,
+					 sigmask, sigsetsize);
+	} else if (sigsetsize == sizeof(_la_ow_sigset_t)) {
+		int rc = p_sys_epoll_pwait(epfd, events, maxevents, timeout,
+					   sigmask, sizeof(sigset_t));
+		if (rc < 0) {
+			return rc;
+		}
+		return rc;
+	} else {
+		return -EINVAL;
+	}
+}
+
+__SYSCALL_DEFINEx(6, _epoll_pwait2, int, epfd, struct epoll_event __user *,
+		  events, int, maxevents,
+		  const struct __kernel_timespec __user *, timeout,
+		  const sigset_t __user *, sigmask, size_t, sigsetsize)
+{
+	if (sigmask == NULL || sigsetsize == sizeof(sigset_t)) {
+		return p_sys_epoll_pwait2(epfd, events, maxevents, timeout,
+					  sigmask, sigsetsize);
+	} else if (sigsetsize == sizeof(_la_ow_sigset_t)) {
+		int rc = p_sys_epoll_pwait2(epfd, events, maxevents, timeout,
+					    sigmask, sizeof(sigset_t));
+		if (rc < 0) {
+			return rc;
+		}
+		return rc;
+	} else {
+		return -EINVAL;
+	}
+}
+
+#endif
+
+#ifdef CONFIG_SIGNALFD
+
+__SYSCALL_DEFINEx(4, _signalfd4, int, ufd, sigset_t __user *, user_mask, size_t,
+		  sizemask, int, flags)
+{
+	if (sizemask == sizeof(sigset_t)) {
+		return p_sys_signalfd4(ufd, user_mask, sizemask, flags);
+	} else if (sizemask == sizeof(_la_ow_sigset_t)) {
+		int rc = p_sys_signalfd4(ufd, user_mask, sizeof(sigset_t),
+					 flags);
+		if (rc < 0) {
+			return rc;
+		}
+		return rc;
+	} else {
+		return -EINVAL;
+	}
+}
+
+#endif
diff --git a/arch/loongarch/ow_syscall/signal.h b/arch/loongarch/ow_syscall/signal.h
new file mode 100644
index 000000000000..a640b39e982d
--- /dev/null
+++ b/arch/loongarch/ow_syscall/signal.h
@@ -0,0 +1,41 @@
+#include <linux/syscalls.h>
+
+#ifndef __EXTERN
+#define __EXTERN extern
+#endif
+#define P__SYSCALL_DEFINEx(x, name, ...) \
+	__EXTERN int (*p_sys##name)(__MAP(x, __SC_DECL, __VA_ARGS__))
+
+P__SYSCALL_DEFINEx(4, _rt_sigprocmask, int, how, sigset_t __user *, nset,
+		   sigset_t __user *, oset, size_t, sigsetsize);
+
+P__SYSCALL_DEFINEx(2, _rt_sigpending, sigset_t __user *, uset, size_t,
+		   sigsetsize);
+
+P__SYSCALL_DEFINEx(4, _rt_sigtimedwait, const sigset_t __user *, uthese,
+		   siginfo_t __user *, uinfo,
+		   const struct __kernel_timespec __user *, uts, size_t,
+		   sigsetsize);
+
+P__SYSCALL_DEFINEx(4, _rt_sigaction, int, sig, const struct sigaction __user *,
+		   act, struct sigaction __user *, oact, size_t, sigsetsize);
+
+P__SYSCALL_DEFINEx(2, _rt_sigsuspend, sigset_t __user *, unewset, size_t,
+		   sigsetsize);
+P__SYSCALL_DEFINEx(6, _pselect6, int, n, fd_set __user *, inp, fd_set __user *,
+		   outp, fd_set __user *, exp,
+		   struct __kernel_timespec __user *, tsp, void __user *, sig);
+#ifdef CONFIG_SIGNALFD
+P__SYSCALL_DEFINEx(4, _signalfd4, int, ufd, sigset_t __user *, user_mask,
+		   size_t, sizemask, int, flags);
+#endif
+#ifdef CONFIG_EPOLL
+P__SYSCALL_DEFINEx(6, _epoll_pwait, int, epfd, struct epoll_event __user *,
+		   events, int, maxevents, int, timeout,
+		   const sigset_t __user *, sigmask, size_t, sigsetsize);
+P__SYSCALL_DEFINEx(6, _epoll_pwait2, int, epfd, struct epoll_event __user *,
+		   events, int, maxevents,
+		   const struct __kernel_timespec __user *, timeout,
+		   const sigset_t __user *, sigmask, size_t, sigsetsize);
+#undef P__SYSCALL_DEFINEx
+#endif
-- 
2.46.0

